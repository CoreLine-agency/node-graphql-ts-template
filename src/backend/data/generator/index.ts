import * as bluebird from 'bluebird';
import * as fs from 'fs';
import { lowerFirst } from 'lodash';
import * as makeDir from 'make-dir';
import * as path from 'path';

import { findBetween, replaceBetween } from '../../utils/find-between';
import { generateAuthChecker } from './generate-auth-checker';
import { generateCrudResolver } from './generate-crud-resolver';
import { generateEnum } from './generate-enum';
import { generateSingleModel } from './generate-er-model';
import { generateFieldResolver } from './generate-field-resolver';
import { generateInput } from './generate-input';
import { generateUpdateOperations } from './generate-update-operations';
import { IGeneratorContext } from './generator-context';
import { getEnumName, isEnum } from './model-types';
import { parseErModel } from './parse-er-model';

const modelData = fs.readFileSync(path.join(__dirname, '..', 'model.er'), 'utf8');
const models = parseErModel(modelData);

function insertOldContent(newContent, oldContent, start, end) {
  const contentToKeep = findBetween(oldContent, start, end);
  if (!contentToKeep) {
    return newContent;
  }

  return replaceBetween(newContent, start, end, contentToKeep);
}

function cleanUp(data: string) {
  return data
    .replace(/\n\n+/g, '\n\n')
    .replace(/{\n\n/g, '{\n')
    .replace(/\n\n}/g, '\n}');
}

const keepingTags = [{
  start: '// <keep-methods>',
  end: '// </keep-methods>',
}, {
  start: '// <keep-imports>',
  end: '// </keep-imports>',
}, {
  start: '// <keep-update-code>',
  end: '// </keep-update-code>',
}, {
  start: '// <keep-decorators>',
  end: '// </keep-decorators>',
}];

const autogeneratedWarning = '/*** AUTOGENERATED FILE: you can only modify parts of the file within <keep-*> tags ***/';

async function writeToFile(data: string, dir: string, name: string, overwrite: boolean) {
  const dirName = path.join(__dirname, '..', dir);
  await makeDir(dirName);

  const filePath = path.join(dirName, name);

  if (!overwrite && fs.existsSync(filePath)) {
    // tslint:disable-next-line no-console
    console.info(`skipping ${name} because it already exists`);

    return;
  }

  let newContent;
  try {
    const oldContent = fs.readFileSync(filePath, 'utf8');
    newContent = cleanUp(data);
    for (const { start, end } of keepingTags) {
      newContent = insertOldContent(newContent, oldContent, start, end);
    }
  } catch (e) {
    newContent = cleanUp(data);
  }

  fs.writeFileSync(filePath, overwrite ? `${autogeneratedWarning}\n${newContent}` : newContent, {
    encoding: 'utf8',
  });
}

function fileToGeneratorContext(dir: string, name: string): IGeneratorContext {
  const dirName = path.join(__dirname, '..', dir);
  const filePath = path.join(dirName, name);
  let existingContent;
  try {
    existingContent = fs.readFileSync(filePath, 'utf8');
  } catch (e) {
    existingContent = '';
  }

  return { existingContent };
}

(async () => {
  for (const model of models) {
    const { name } = model;

    const createInput = generateInput(model, 'create');
    const editInput = generateInput(model, 'edit');
    const nestedInput = generateInput(model, 'nested');
    const searchInput = generateInput(model, 'search');
    const searchOrder = generateInput(model, 'searchOrder');
    const dbModel = generateSingleModel(model, fileToGeneratorContext('models', `${name}.ts`));
    const resolver = generateFieldResolver(model);
    const crudResolver = generateCrudResolver(model);
    const authChecker = generateAuthChecker(model);
    const updateOperations = generateUpdateOperations(model);

    await writeToFile(createInput, 'inputs', `${name}CreateInput.ts`, true);
    await writeToFile(editInput, 'inputs', `${name}EditInput.ts`, true);
    await writeToFile(nestedInput, 'inputs', `${name}NestedInput.ts`, true);
    await writeToFile(searchInput, 'inputs', `${name}SearchInput.ts`, true);
    await writeToFile(searchOrder, 'inputs', `${name}SearchOrderInput.ts`, true);

    await writeToFile(dbModel, 'models', `${name}.ts`, true);
    await writeToFile(resolver, 'field-resolvers', `${name}Resolver.ts`, false);
    await writeToFile(crudResolver, 'resolvers', `${name}CrudResolver.ts`, true);

    await bluebird.each(model.fields.filter(isEnum), async (field) => {
      const enumName = getEnumName(field);
      await writeToFile(generateEnum(model, field), 'enums', `${enumName}.ts`, true);
    });

    await writeToFile(authChecker, 'auth', `${name}Auth.ts`, false);
    await writeToFile(updateOperations, `models/update-operations`, `${lowerFirst(name)}-update-operations.ts`, true);
  }
})();
